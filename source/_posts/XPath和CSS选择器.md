---
title: [译]XPath和CSS选择器
date: 2013-07-18 00:00:00
comments: true
tags:
    - XPath
    - CSS
    - 选择器
categories:
    - CSS
---

原文: [http://ejohn.org/blog/xpath-css-selectors](http://ejohn.org/blog/xpath-css-selectors)

最近,我做了很多工作来实现一个同时支持XPath和CSS 3的解析器,令我惊讶的是:它们俩在某些方面上非常相似,而在另一些方面上又完全不同。不同的地方有,CSS是用来配合HTML工作的,可以使用#id来根据ID获取元素,以及使用.class来根据class获取元素，这些用XPath实现的话都不会那么简洁,反过来呢,XPath可以使用..来返回到DOM树的上层节点中,还可以使用foo[bar]来获取到一个拥有bar子元素的foo元素。CSS选择器完全做不到这些，总结一下就是，和XPath比起来，CSS选择器通常都比较短小，但可惜的是不够强大。

我认为将这两种选择器的写法做一个比较是很有价值的。

``` rst
+-------------------------+--------------------+-------------------------------+
| 目标                    | CSS3               | XPath                         |
+=========================+====================+===============================+
| 所有元素                | \*                 | //\*                          |
+-------------------------+--------------------+-------------------------------+
| 所有的p元素             | p                  | //p                           |
+-------------------------+--------------------+-------------------------------+
| 所有的p元素的子元素     | p > \*             | //p/\*                        |
+-------------------------+--------------------+-------------------------------+
| 根据ID获取元素          | #foo               | //\*[@id='foo']               |
+-------------------------+--------------------+-------------------------------+
| 根据Class获取元素       | .foo               | //\*[contains(@class, 'foo')] |
+-------------------------+--------------------+-------------------------------+
| 拥有摸个属性的元素      | \*[title]          | //\*[@title]                  |
+-------------------------+--------------------+-------------------------------+
| 所有p元素的第一个子元素 | p > \*:first-child | //p/\*[0]                     |
+-------------------------+--------------------+-------------------------------+
| 所有拥有子元素a的p元素  | 无法实现           | //p[a]                        |
+-------------------------+--------------------+-------------------------------+
| 下一个兄弟元素          | p + \*             | //p/following-sibling::\*[0]  |
+-------------------------+--------------------+-------------------------------+
```

注:
上表中错误的XPath:
//\*[contains(@class,'foo')]
我实现的写法是:
//\*[@class='foo' or contains(@class,' foo ') or starts-with(@class,'foo ') or substring(@class,string-length(@class)-3)=' foo']
